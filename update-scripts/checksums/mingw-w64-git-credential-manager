#!/usr/bin/env node

// The `PKGBUILD` file of `mingw-w64-git-credential-manager` uses a `case`
// statement to select architecture-specific artifacts and their checksums.

// This script fetches the checksums from the GitHub release page and updates
// the PKGBUILD accordingly.

(async () => {
    const version = process.argv[2]

    const githubApiRequest = require('../../github-api-request')
    const { assets } = await githubApiRequest(
        console,
        null,
        'GET',
        `/repos/git-ecosystem/git-credential-manager/releases/tags/v${version}`
    )

    // Map architecture names from GitHub assets to MSYS2 architecture names
    const archMap = {
        'x86': 'i686',
        'x64': 'x86_64',
        'arm64': 'aarch64'
    }

    const sha256sums = {}
    let sourceArchiveSha = null

    // Find checksums from the release assets (GitHub provides sha256 digests)
    for (const asset of assets) {
        const match = asset.name.match(/^gcm-win-(x86|x64|arm64)-\S+\.zip$/)
        if (match) {
            const arch = match[1]
            const msys2Arch = archMap[arch]
            // Use the digest from GitHub's API
            if (asset.digest && asset.digest.sha256) {
                sha256sums[msys2Arch] = asset.digest.sha256
            }
        }
    }

    // Get the source archive checksum
    const sourceAsset = assets.find(a => a.name === `git-credential-manager-${version}.tar.gz` || a.name === 'Source code (tar.gz)')
    if (sourceAsset && sourceAsset.digest && sourceAsset.digest.sha256) {
        sourceArchiveSha = sourceAsset.digest.sha256
    }

    // Alternatively, download and compute the checksums ourselves
    if (!sha256sums.i686 || !sha256sums.x86_64 || !sha256sums.aarch64 || !sourceArchiveSha) {
        const crypto = require('crypto')
        const https = require('https')
        const agent = new https.Agent({ keepAlive: false })

        const computeSha256 = async (url) => {
            console.error(`Downloading ${url.length > 120 ? url.substring(0, 117) + '...' : url}`)
            return new Promise((resolve, reject) => {
                https.get(url, { agent }, (response) => {
                    // Follow redirects
                    if (response.statusCode === 301 || response.statusCode === 302) {
                        return computeSha256(response.headers.location).then(resolve).catch(reject)
                    }
                    if (response.statusCode !== 200) {
                        reject(new Error(`HTTP ${response.statusCode}`))
                        return
                    }
                    const hash = crypto.createHash('sha256')
                    response.on('data', (chunk) => hash.update(chunk))
                    response.on('end', () => resolve(hash.digest('hex')))
                }).on('error', reject)
            })
        }

        console.log('Computing SHA256 checksums from artifacts...')
        const baseUrl = `https://github.com/git-ecosystem/git-credential-manager/releases/download/v${version}`

        sha256sums.i686 = await computeSha256(`${baseUrl}/gcm-win-x86-${version}.zip`)
        sha256sums.x86_64 = await computeSha256(`${baseUrl}/gcm-win-x64-${version}.zip`)
        sha256sums.aarch64 = await computeSha256(`${baseUrl}/gcm-win-arm64-${version}.zip`)
        sourceArchiveSha = await computeSha256(`https://github.com/git-ecosystem/git-credential-manager/archive/v${version}.zip`)
    }

    if (!sha256sums.i686 || !sha256sums.x86_64 || !sha256sums.aarch64 || !sourceArchiveSha) {
        throw new Error('Could not obtain all required checksums')
    }

    console.log(`Checksums for v${version}:`)
    console.log(`  i686:     ${sha256sums.i686}`)
    console.log(`  x86_64:   ${sha256sums.x86_64}`)
    console.log(`  aarch64:  ${sha256sums.aarch64}`)
    console.log(`  source:   ${sourceArchiveSha}`)

    // Update the PKGBUILD file
    const fs = require('fs')
    const lines = fs.readFileSync('PKGBUILD').toString('utf-8').split(/\r?\n/)

    let currentArch = null
    lines.forEach((line, i) => {
        let match

        // Detect which architecture case we're in
        if ((match = line.match(/^\s*mingw-w64-(i686|x86_64|clang-aarch64)\)$/))) {
            const msys2Arch = match[1] === 'clang-aarch64' ? 'aarch64' : match[1]
            currentArch = msys2Arch
        } else if (line.match(/^\s*\*\)$/)) {
            // Default case, use i686
            currentArch = 'i686'
        } else if ((match = line.match(/^(\s*_sha=)[0-9a-f]{64}$/))) {
            // Update the _sha variable with the correct checksum
            if (currentArch && sha256sums[currentArch]) {
                lines[i] = `${match[1]}${sha256sums[currentArch]}`
            }
        } else if ((match = line.match(/^(\s*)'[0-9a-f]{64}'(\s*)\)?\s*$/))) {
            // Update the source archive checksum in sha256sums array
            lines[i] = `${match[1]}'${sourceArchiveSha}'${match[2]})`
        }
    })

    fs.writeFileSync('PKGBUILD', lines.join('\n'))
    console.log('PKGBUILD updated successfully')
})().catch((err) => {console.log(err); process.exit(1)})
